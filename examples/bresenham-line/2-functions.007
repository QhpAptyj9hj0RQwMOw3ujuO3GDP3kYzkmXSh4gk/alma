# Draws a line from (x1, y1) to (x2, y2).
#
# Usage:
#
#   bin/007 examples/bresenham-line/2-functions.007 10 12 69 12     # horizontal
#   bin/007 examples/bresenham-line/2-functions.007 40 5 40 19      # vertical
#   bin/007 examples/bresenham-line/2-functions.007 10 5 69 19      # slanted
#
# The four arguments `x1 y1 x2 y2` are mandatory. The range of the
# x coordinates is (0, 79) inclusive, and of y (0, 24) inclusive.
# Coordinates must be within these ranges, or an error will be thrown.

my HEIGHT = 25;
my WIDTH = 80;

my EMPTY = ".";
my FILLED = "#";

macro infix:<xx>(left, right) is equiv(infix:<*>) {
    func flatten(array) {
        my result = [];
        for array -> elem {
            if elem ~~ Array {
                result = result.concat(elem);
            } else {
                result.push(elem);
            }
        }
        return result;
    }

    return quasi {
        flatten((^{{{right}}}).map(func(_) {
            return {{{left}}};
        }))
    }
}

func inBetween(n1, n2) {
    my low;
    my high;
    if n1 <= n2 {
        low = n1;
        high = n2;
    }
    else {
        low = n2;
        high = n1;
    }

    my result = [];
    for ^(high - low + 1) -> i {
        result.push(low + i);
    }
    return result;
}

func half(n) {
    return (n divmod 2)[0];
}

func checkBounds(value, min, max) {
    value = +value;
    if value < min {
        throw new Exception {
            message: "Value is too small. " ~ value ~ " !~~ " ~ min ~ ".." ~ max,
        };
    }
    if value > max {
        throw new Exception {
            message: "Value is too large. " ~ value ~ " !~~ " ~ min ~ ".." ~ max,
        };
    }
    return value;
}

func if(cond, thenValue, elseValue) {
    if cond {
        return thenValue;
    }
    else {
        return elseValue;
    }
}

func sgn(n) {
    return if(n > 0,
        +1,
        if(n == 0,
            0,
            -1
        )
    );
}

func drawLine(x1, y1, x2, y2, pixelCallback) {
    my dx = (x2 - x1).abs();
    my dy = (y2 - y1).abs();
    my step = sgn(x2 - x1) * sgn(y2 - y1);

    # For each increase in x, we also increase y by dy/dx. Bresenham's
    # algorithm finds the integer y coordinate which best fits this
    # rational y coordinate.
    #
    # 007 doesn't have rationals. Fortunately, we can just multiply
    # everything by dx, and things come out as integers again.

    my y = if(x1 <= x2, y1, y2);
    my i = half(dx);
    for inBetween(x1, x2) -> x {
        i = i + dy;
        if i >= dx {
            i = i - dx;
            y = y + step;
        }
        pixelCallback(x, y);
    }
}

# Draws a line from (x1, y1) to (x2, y2).
#
# A coordinate space between (0, 0) (upper left) and (79, 24) (lower right)
# is printed. The line is drawn within that space. The specified
# coordinates must be within this space.
func MAIN(x1, y1, x2, y2) {
    my space = [[EMPTY] xx WIDTH] xx HEIGHT;

    x1 = checkBounds(x1, 0, 79);
    x2 = checkBounds(x2, 0, 79);
    y1 = checkBounds(y1, 0, 24);
    y2 = checkBounds(y2, 0, 24);

    if (x2 - x1).abs() >= (y2 - y1).abs() {
        drawLine(x1, y1, x2, y2, func (x, y) { space[y][x] = FILLED });
    }
    else {
        drawLine(y1, x1, y2, x2, func (y, x) { space[y][x] = FILLED });
    }

    for space -> row {
        say(row.join(""));
    }
}
