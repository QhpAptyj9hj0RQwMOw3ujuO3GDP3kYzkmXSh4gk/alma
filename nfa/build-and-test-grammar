#! /usr/local/bin/perl6
use Test;

class Shortcut {
    has Str $.type;
}

role Grammar {
    token grammar {
        'grammar' <.ws> '{'
            <.ws>
            <rule>*
        '}'
        <.ws>

        {
            die "There must be a 'TOP' rule defined"
                unless 'TOP' ∈ $<rule>».ast»<name>;
            make $<rule>».ast;
        }
    }

    token rule {
        'token' <.ws> <ident> <.ws> '{'
            <.ws>
            $<contents>=[<atom>*]
        ['}' || <panic("Expected regex atom or '}'")>]
        <.ws>

        {
            make {
                name => ~$<ident>,
                contents => ~$<contents>,
                atoms => $<atom>».ast,
            };
        }
    }

    proto token atom {*}

    token atom:literal {
        <[']>
            $<literal>=(<-[']>*)
        <[']>
        <.ws>

        { make ~$<literal> }
    }

    token atom:character-class {
        '<['
            <charclass-element>*
        ']>'
        <.ws>

        { make (my Range @ = $<charclass-element>».ast) }
    }

    token atom:charclass-shortcut {
        '\\'
        $<type>=<[wdhsWDHS]>
        <.ws>

        { make Shortcut.new(type => ~$<type>) }
    }

    proto token charclass-element {*}

    token charclass-element:char {
        <-[\]]>

        { make Range.new(~$/, ~$/) }
    }

    token charclass-element:range {
        $<from>=<-[\]]>
        '..'
        $<to>=<-[\]]>

        { make Range.new(~$<from>, ~$<to>) }
    }

    method panic($) { ... }
}

role Spec {
    token spec {
        <section>*
        { make $<section>».ast }
    }

    token section {
        <heading> \n
        [<.empty-line> | <section-line>]*
        {
            make {
                heading => $<heading>.ast,
                lines => $<section-line>».ast,
            };
        }
    }

    token heading {
        ^^ '##' \h* $<heading>=(\N+) \n
        {
            my $heading = ~$<heading>;
            die "Sorry, unrecognized heading `$heading`"
                unless $heading eq "Happy parse" | "Sad parse";
            make ~$<heading>;
        }
    }

    token empty-line {
        ^^ \h* \n
    }

    token section-line {
        ^^ <[']> $<line>=(<-[']>*) <[']> \n
        { make $<line>.Str.trans(['\\f', '\\n', '\\r', '\\t'] => ["\f", "\n", "\r", "\t"]) }
    }
}

grammar GrammarSpec does Grammar does Spec {
    token TOP {
        <.ws>
        <grammar>
        <spec>

        {
            make {
                grammar => $<grammar>.ast,
                spec => $<spec>.ast,
            }
        }
    }

    method panic($message) {
        my $pos = self.pos;
        my $orig = self.orig;

        sub de-nl($s) {
            $s.subst(/\n/, "\x[2424]", :g);
        }

        my $before-length = 12;
        my $before = de-nl $orig.substr( ($pos - $before-length max 0) ..^ $pos );
        my $before-ellipsis = $pos - $before-length > 0
            ?? "..."
            !! "";

        my $snippet-length = 12;
        my $snippet = de-nl $orig.substr($pos, $snippet-length);
        my $snippet-ellipsis = $pos < $orig.chars - $snippet-length
            ?? "..."
            !! "";

        my $some-text = "$before-ellipsis$before⏏$snippet$snippet-ellipsis";
        note "Parse failed: $message (`$some-text` at pos $pos)";
        exit 1;
    }
}

class State {
    has Int $.id;
    has Bool $.goal = False;
    has @.transitions;

    method add-transition-to(State :$next-state!, :$matcher!) {
        @.transitions.push(transition(:$next-state, :$matcher));
    }

    method mark-as-goal() {
        $!goal = True;
    }
}

sub escape($s) {
    $s.trans(["\f", "\n", "\r", "\t"] => ['\\f', '\\n', '\\r', '\\t']);
}

role Transition {
    has State $.next-state;

    method matches(Str $char) { ... }
}

class Transition::Char does Transition {
    has Str $.char;

    method Str { qq["{escape($.char)}"] }
    method matches(Str $char) { $char eq $.char }
}

class Transition::Ranges does Transition {
    has Range @.ranges;

    sub format($r) {
        $r.min eq $r.max
            ?? qq["{escape($r.min)}"]
            !! qq[{escape($r.min)}..{escape($r.max)}];
    }
    method Str { @.ranges.map(&format).join(", ") }
    method matches(Str $char) { so $char ~~ any(@.ranges) }
}

multi transition(State :$next-state!, Str :$matcher!) {
    Transition::Char.new(:$next-state, char => $matcher);
}

multi transition(State :$next-state!, Range :@matcher!) {
    Transition::Ranges.new(:$next-state, ranges => @matcher);
}

multi transition(State :$next-state!, :$matcher!) {
    die "Unrecognized charclass element type: ", $matcher.^name;
}

class NFA {
    has Str $.name;
    has Str $.contents;
    has State @.states;
    has State $!current-state;
    has Int $!next-unique-id;

    submethod BUILD(:$!name!, :$!contents!) {
        $!next-unique-id = 0;
        my $start-state = self!add-state();
        $!current-state = $start-state;
    }

    method !add-state() {
        my $state = State.new(id => $!next-unique-id++);
        @!states.push($state);
        return $state;
    }

    method add-state-with-transition($matcher) {
        my $next-state = self!add-state();
        if $matcher !~~ Array[Range] || +$matcher { # no need to add an empty transition
            $!current-state.add-transition-to(:$next-state, :$matcher);
        }
        $!current-state = $next-state;
        return;
    }

    method mark-current-state-as-goal() {
        $!current-state.mark-as-goal();
        return;
    }

    method start-state() {
        return @!states[0];
    }
}

sub dump-nfa(NFA $nfa) {
    constant $INDENT = " " x 4;
    say "# NFA for token ", $nfa.name, " \{ ", $nfa.contents, " \} ";
    for $nfa.states -> $state {
        say "# ", $INDENT, "STATE ", $state.id, ($state.goal ?? " (goal)" !! "");
        for $state.transitions -> $t {
            my $arrow = "---[{$t.Str}]--->";

            say "# {$INDENT x 2}{$arrow} {$t.next-state.id}";
        }
    }
    say "";
}

sub run-nfa(NFA $nfa, Str $input) {
    my $current-states = set($nfa.states[0]);
    for $input.comb -> $char {
        my $next-states = set();
        for $current-states.keys -> $state {
            for $state.transitions -> $t {
                if $t.matches($char) {
                    $next-states ∪= set($t.next-state);
                }
            }
        }
        $current-states = $next-states;
    }
    return ?any($current-states.keys».goal);
}

my (:$grammar, :$spec) := GrammarSpec.parse(slurp()).ast;
my @rules = @$grammar;
my %nfa-for-rule;

for @rules -> $rule {
    my $name = $rule<name>;
    my $contents = $rule<contents>;
    my $nfa = NFA.new(:$name, :$contents);
    for @($rule<atoms>) -> $atom {
        if $atom ~~ Str {               # literal
            for $atom.comb -> $char {
                $nfa.add-state-with-transition($char);
            }
        }
        elsif $atom ~~ Array[Range] {   # character class
            $nfa.add-state-with-transition($atom);
        }
        elsif $atom ~~ Shortcut {
            sub r($c) { $c..$c }
            my Range @elements = do given $atom.type {
                when "d" { ("0".."9",) }
                when "w" { "0".."9", "A".."Z", "a".."z", r("_") }
                when "s" { r("\x[20]"), "\x[09]".."\x[0D]" }
                when "h" { r("\x[20]"), r("\x[09]") }
            };
            $nfa.add-state-with-transition(@elements);
        }
        else {                          # unknown
            die "Unrecognized atom type: ", $atom.^name;
        }
    }
    $nfa.mark-current-state-as-goal();
    dump-nfa($nfa);
    %nfa-for-rule{$name} = $nfa;
}
my $top-nfa = %nfa-for-rule<TOP>;

my @sections = @$spec;
for @sections -> $section {
    my $heading = $section<heading>;
    my $expected-result = $heading eq "Happy parse";
    my $expectation = $expected-result
        ?? "should succeed"
        !! "should fail";
    for @($section<lines>) -> $line {
        my $escaped-line = escape($line);
        ok run-nfa($top-nfa, $line) == $expected-result, "$heading: parsing '$escaped-line' $expectation";
    }
}

done-testing;
