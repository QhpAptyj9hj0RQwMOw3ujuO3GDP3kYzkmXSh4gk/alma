#! /usr/local/bin/perl6
use Test;

role Grammar {
    token grammar {
        'grammar' <.ws> '{'
            <.ws>
            <rule>*
        '}'
        <.ws>

        {
            die "There must be a 'TOP' rule defined"
                unless 'TOP' ∈ $<rule>».ast»<name>;
            make $<rule>».ast;
        }
    }

    token rule {
        'token' <.ws> <ident> <.ws> '{'
            <.ws>
            <atom>*
        ['}' || <panic("Expected regex atom or '}'")>]
        <.ws>

        {
            make {
                name => ~$<ident>,
                atoms => $<atom>».ast,
            };
        }
    }

    proto token atom {*}

    token atom:literal {
        <[']>
            $<literal>=(<-[']>*)
        <[']>
        <.ws>

        { make ~$<literal> }
    }

    token atom:character-class {
        '<['
            <charclass-element>*
        ']>'
        <.ws>

        { make $<charclass-element>».ast }
    }

    proto token charclass-element {*}

    token charclass-element:char {
        <-[\]]>

        { make ~$/ }
    }

    token charclass-element:range {
        $<from>=<-[\]]>
        '..'
        $<to>=<-[\]]>

        { make Range.new(~$<from>, ~$<to>) }
    }

    method panic($) { ... }
}

role Spec {
    token spec {
        <section>*
        { make $<section>».ast }
    }

    token section {
        <heading> \n
        [<.empty-line> | <section-line>]*
        {
            make {
                heading => $<heading>.ast,
                lines => $<section-line>».ast,
            };
        }
    }

    token heading {
        ^^ '##' \h* $<heading>=(\N+) \n
        {
            my $heading = ~$<heading>;
            die "Sorry, unrecognized heading `$heading`"
                unless $heading eq "Happy parse" | "Sad parse";
            make ~$<heading>;
        }
    }

    token empty-line {
        ^^ \h* \n
    }

    token section-line {
        ^^ <[']> $<line>=(<-[']>*) <[']> \n
        { make ~$<line> }
    }
}

grammar GrammarSpec does Grammar does Spec {
    token TOP {
        <.ws>
        <grammar>
        <spec>

        {
            make {
                grammar => $<grammar>.ast,
                spec => $<spec>.ast,
            }
        }
    }

    method panic($message) {
        my $pos = self.pos;
        my $orig = self.orig;

        sub de-nl($s) {
            $s.subst(/\n/, "\x[2424]", :g);
        }

        my $before-length = 12;
        my $before = de-nl $orig.substr( ($pos - $before-length max 0) ..^ $pos );
        my $before-ellipsis = $pos - $before-length > 0
            ?? "..."
            !! "";

        my $snippet-length = 12;
        my $snippet = de-nl $orig.substr($pos, $snippet-length);
        my $snippet-ellipsis = $pos < $orig.chars - $snippet-length
            ?? "..."
            !! "";

        my $some-text = "$before-ellipsis$before⏏$snippet$snippet-ellipsis";
        note "Parse failed: $message (`$some-text` at pos $pos)";
        exit 1;
    }
}

class State {
    has Int $.id;
    has Bool $.goal = False;
    has @.transitions;

    method add-transition-to(State :$next-state!, :$matcher!) {
        @.transitions.push(transition(:$next-state, :$matcher));
    }

    method mark-as-goal() {
        $!goal = True;
    }
}

role Transition {
    has State $.next-state;

    method matches(Str $char) { ... }
}

class Transition::Char does Transition {
    has Str $.char;

    method Str { "'$.char'" }
    method matches(Str $char) { $char eq $.char }
}

class Transition::Range does Transition {
    has Range $.range;

    method Str { $.range.min ~ ".." ~ $.range.max }
    method matches(Str $char) { $char ~~ $.range }
}

multi transition(State :$next-state!, Str :$matcher!) {
    Transition::Char.new(:$next-state, char => $matcher);
}

multi transition(State :$next-state!, Range :$matcher!) {
    Transition::Range.new(:$next-state, range => $matcher);
}

multi transition(State :$next-state!, :$matcher!) {
    die "Unrecognized charclass element type: ", $matcher.^name;
}

class NFA {
    has Str $.name;
    has State @.states;
    has State $!current-state;
    has Int $!next-unique-id;

    submethod BUILD(:$!name!) {
        $!next-unique-id = 0;
        my $start-state = self!add-state();
        $!current-state = $start-state;
    }

    method !add-state() {
        my $state = State.new(id => $!next-unique-id++);
        @!states.push($state);
        return $state;
    }

    method add-char($char) {
        my $next-state = self!add-state();
        $!current-state.add-transition-to(:$next-state, matcher => $char);
        $!current-state = $next-state;
        return;
    }

    method add-char-class(@elements) {
        my $next-state = self!add-state();
        for @elements -> $matcher {
            $!current-state.add-transition-to(:$next-state, :$matcher);
        }
        $!current-state = $next-state;
        return;
    }

    method mark-current-state-as-goal() {
        $!current-state.mark-as-goal();
        return;
    }

    method start-state() {
        return @!states[0];
    }
}

sub dump-nfa(NFA $nfa) {
    constant $INDENT = " " x 4;
    say "# NFA for ", $nfa.name;
    for $nfa.states -> $state {
        say "# ", $INDENT, "STATE ", $state.id, ($state.goal ?? " (goal)" !! "");
        for $state.transitions -> $t {
            say "# ", $INDENT x 2, "---[", $t.Str, "]---> ", $t.next-state.id;
        }
    }
    say "";
}

sub run-nfa(NFA $nfa, Str $input) {
    my $current-states = set($nfa.states[0]);
    for $input.comb -> $char {
        my $next-states = set();
        for $current-states.keys -> $state {
            for $state.transitions -> $t {
                if $t.matches($char) {
                    $next-states ∪= set($t.next-state);
                }
            }
        }
        $current-states = $next-states;
    }
    return ?any($current-states.keys».goal);
}

my (:$grammar, :$spec) := GrammarSpec.parse(slurp()).ast;
my @rules = @$grammar;
my %nfa-for-rule;

for @rules -> $rule {
    my $name = $rule<name>;
    my $nfa = NFA.new(:$name);
    for @($rule<atoms>) -> $atom {
        if $atom ~~ Str {       # literal
            for $atom.comb -> $char {
                $nfa.add-char($char);
            }
        }
        elsif $atom ~~ List {   # character class
            $nfa.add-char-class($atom);
        }
        else {                  # unknown
            die "Unrecognized atom type: ", $atom.^name;
        }
    }
    $nfa.mark-current-state-as-goal();
    dump-nfa($nfa);
    %nfa-for-rule{$name} = $nfa;
}
my $top-nfa = %nfa-for-rule<TOP>;

my @sections = @$spec;
for @sections -> $section {
    my $heading = $section<heading>;
    my $expected-result = $heading eq "Happy parse";
    my $expectation = $expected-result
        ?? "should succeed"
        !! "should fail";
    for @($section<lines>) -> $line {
        ok run-nfa($top-nfa, $line) == $expected-result, "$heading: parsing '$line' $expectation";
    }
}

done-testing;
