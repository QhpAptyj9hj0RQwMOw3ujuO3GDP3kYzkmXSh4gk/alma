## minimal test framework

my ANSI_GREEN = 27.chr() ~ "[1;32m";
my ANSI_RED = 27.chr() ~ "[1;31m";
my ANSI_RESET = 27.chr() ~ "[m";

my testsRun = 0;

func is(actual, expected, message) {
    my status = "ok";
    my colorCode = ANSI_GREEN;
    my cond = actual == expected;
    if !cond {
        status = "NOT OK";
        colorCode = ANSI_RED;
    }
    say(colorCode, status, ANSI_RESET, " - ", message);
    if !cond {
        say("# Expected: ", expected);
        say("# Got: ", actual);
    }
    testsRun = testsRun + 1;
}

func done() {
    say("1..", testsRun);
}

## grammar/parser stuff

my RX_SEQUENCE = "<sequence>";
my RX_POS_CAPTURE = "<positional capture>";
my RX_BLOCK = "<block>";
my RX_QUANT_1_OR_MORE = "<quantifier(+)>";
my RX_CCLASS = "<character class>";
my CC_RANGE = "<cclass range>";

my grammar = {
    "TOP":
        [RX_SEQUENCE,
            [RX_POS_CAPTURE,
                [RX_QUANT_1_OR_MORE,
                    [RX_CCLASS, [CC_RANGE, "a", "z"]]
                ]
            ],
            [RX_BLOCK, func (match) {
                my name = match["pos"][0];
                return new Q.Term.Identifier { name };
            }],
        ],
};

func parse(input) {
    my match = {
        "pos": [],
    };

    # Returns either an array `[newPos, ast]` on success,
    # or `none` on failure.
    func handle(ruleFragment, pos) {
        my fragmentType = ruleFragment[0];
        if fragmentType == RX_SEQUENCE {
            my n = ruleFragment.size();
            my progress = [pos, true];
            for ^n -> i {
                if i != 0 {
                    my element = ruleFragment[i];
                    if !(progress = handle(element, pos)) {
                        return none;
                    }
                    pos = progress[0];
                }
            }
            return progress;
        }
        else if fragmentType == RX_POS_CAPTURE {
            my atom = ruleFragment[1];
            my fromPos = pos;
            my result = handle(atom, fromPos);
            if result == none {
                return none;
            }
            my toPos = result[0];
            match["pos"].push("foo");
            return result;
        }
        else if fragmentType == RX_QUANT_1_OR_MORE {
            my atom = ruleFragment[1];
            if !(my progress = handle(atom, pos)) {
                return none;
            }
            pos = progress[0];
            while (progress = handle(atom, pos)) {
                pos = progress[0];
            }
            return [pos, true];
        }
        else if fragmentType == RX_CCLASS {
            my character = input.substr(pos, 1);
            if character == "" {
                return none;
            }
            # Returns true iff the cclass part matches the character
            func handlePart(part) {
                my partType = part[0];
                if partType == CC_RANGE {
                    my lower = part[1];
                    my upper = part[2];
                    return lower <= character && character <= upper;
                }
                throw new Exception { message: "Unknown cclass part type " ~ partType };
            }
            my n = ruleFragment.size();
            for ^n -> i {
                if i != 0 {
                    my part = ruleFragment[i];
                    if handlePart(part) {
                        return [pos + 1, true];
                    }
                }
            }
            return none;
        }
        else if fragmentType == RX_BLOCK {
            my fn = ruleFragment[1];
            my result = fn(match);
            return [pos, result];
        }
        throw new Exception { message: "Unknown fragment type " ~ fragmentType };
    }

    my result = handle(grammar["TOP"], 0);
    if result == none {
        return none;
    }
    else {
        return result[1];
    }
}

## the tests

is(
    parse(""),
    none,
    "an empty input does not match"
);

is(
    parse("foo"),
    new Q.Term.Identifier { name: "foo" },
    "matching an identifier"
);

done();
