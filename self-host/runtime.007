my ast = Q::CompUnit {
    block: Q::Block {
        parameterlist: Q::ParameterList {},
        statementlist: Q::StatementList {
            statements: []
        }
    }
};

my RealOutput = {
    new() { return { say }; }
};

my Runtime = {
    new(config) {
        my out = config.output;
        my pad = {};
        sub get_var(name) { return pad[name] }
        sub put_var(name, value) { pad[name] = value }

        my eval_of_type = {
            Q::Identifier(ident) {
                return get_var(ident.name);
            },
            Q::Infix::Addition(op) {
                return eval(op.lhs) + eval(op.rhs);
            },
            Q::Infix::Assignment(op) {
                my value = eval(op.rhs);
                put_var(op.lhs.name, value);    # XXX: assumption that lhs is a Q::Identifier
                return value;
            },
            Q::Infix::Concat(op) {
                return eval(op.lhs) ~ eval(op.rhs);
            },
            Q::Infix::Eq(op) {
                return eval(op.lhs) == eval(op.rhs);
            },
            Q::Literal::Int(lit_int) {
                return lit_int.value;
            },
            Q::Literal::Str(lit_str) {
                return lit_str.value;
            },
            Q::Postfix::Call(op) {
                # cheating here for now because we're only using `say`
                return out.say(eval(op.argumentlist.arguments[0]));
            },
            Q::Term::Array(array) {
                return array.elements.map(eval);
            },
        };
        sub eval(q) { return eval_of_type[type(q).name](q); }

        my run_of_type = {
            Q::CompUnit(compunit) {
                for compunit.block.statementlist.statements -> statement {
                    run(statement);
                }
            },
            Q::Statement::Expr(e) {
                eval(e.expr);
            },
            Q::Statement::My(my) {
                if !my.expr {
                    return;
                }
                my value = eval(my.expr);
                put_var(my.identifier.name, value);
            },
        };
        sub run(q) { run_of_type[type(q).name](q); }

        return { run, get_var, put_var };
    }
};

my output = RealOutput.new();
my runtime = Runtime.new({ output });
runtime.run(ast);
