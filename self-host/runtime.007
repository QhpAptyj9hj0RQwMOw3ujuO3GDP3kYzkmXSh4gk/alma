my ast;
if !ast {
    ast = new Q::CompUnit {
        block: new Q::Block {
            parameterlist: new Q::ParameterList {},
            statementlist: new Q::StatementList {
                statements: []
            }
        }
    };
}

my RealOutput = {
    new() { return { say }; }
};

constant NO_OUTER = {};

my Runtime = {
    new(config) {
        my out = config.output;
        my frames = [];
        sub enter(block) {
            my frame = { block, pad: {} };
            frames.push(frame);
            for block["static-lexpad"].keys() -> name {
                my value = block["static-lexpad"][name];
                my identifier = new Q::Identifier { name };
                declare_var(identifier, value);
            }
        }
        sub leave() {
            frames.pop();
        }
        sub current_frame() {
            if !frames {
                return NO_OUTER;
            }
            return frames[frames.elems() - 1];
        }

        sub find_pad(symbol) {
            my frame = current_frame();
            # The below check didn't work
            # while frame.id != NO_OUTER.id {
            # So trying this instead:
            while frame.has("pad") {
                if frame.pad.has(symbol) {
                    return frame.pad;
                }
                frame = frame.block["outer-frame"];
            }
            throw new Exception { message: "Cannot find variable '" ~ symbol ~ "'" };
        }
        sub get_var(name) {
            my pad = find_pad(name);
            return pad[name];
        }
        sub put_var(name, value) {
            my pad = find_pad(name);
            pad[name] = value;
        }
        sub declare_var(identifier, value) {
            my name = identifier.name;
            # XXX: don't know if we should expose identifier.frame in 007
            # my frame = identifier.frame || current_frame();
            my frame = current_frame();
            frame.pad[name] = value;
        }

        sub reify(block) {
            return new Block {
                parameterlist: block.parameterlist,
                statementlist: block.statementlist,
                "static-lexpad": block["static-lexpad"],
                "outer-frame": current_frame(),
            };
        }

        sub sigbind(c, arguments) {
            my paramcount = c.parameterlist.parameters.elems();
            my argcount = arguments.elems();
            if paramcount != argcount {
                throw new Exception { message: "parameter mismatch" };
            }
            enter(c);
            for ^argcount -> i {
                my param = c.parameterlist.parameters[i];
                my arg = arguments[i];
                declare_var(param.identifier, arg);
            }
        }

        sub call(c, arguments) {
            sigbind(c, arguments);
            my frame = current_frame();
            run(c.statementlist);
            leave();
        }

        my eval_of_type = {
            Q::Identifier(ident) {
                return get_var(ident.name);
            },
            Q::Infix::Addition(op) {
                return eval(op.lhs) + eval(op.rhs);
            },
            Q::Infix::Assignment(op) {
                my value = eval(op.rhs);
                if op.lhs ~~ Q::Identifier {    # XXX: this assumption does not always hold
                    put_var(op.lhs.name, value);
                }
                return value;
            },
            Q::Infix::Concat(op) {
                return eval(op.lhs) ~ eval(op.rhs);
            },
            Q::Infix::Eq(op) {
                return eval(op.lhs) == eval(op.rhs);
            },
            Q::Infix::Subtraction(op) {
                return eval(op.lhs) - eval(op.rhs);
            },
            Q::Literal::Int(lit_int) {
                return lit_int.value;
            },
            Q::Literal::Str(lit_str) {
                return lit_str.value;
            },
            Q::Postfix::Call(op) {
                # XXX: short-term hack to get `say` early; needs to go away
                if op.operand ~~ Q::Identifier && op.operand.name == "say" {
                    return out.say(eval(op.argumentlist.arguments[0]));
                }
                my c = eval(op.operand);
                if c ~~ Macro {
                    throw new Exception { message: "macro is called at runtime" };
                }
                if !(c ~~ Block) {
                    throw new Exception { message: "Trying to invoke a " ~ type(c).name };
                }
                my arguments = op.argumentlist.arguments.map(eval);
                return call(c, arguments);
            },
            Q::Postfix::Index(op) {
                return eval(op.operand)[eval(op.index)];
            },
            Q::Term::Array(array) {
                return array.elements.map(eval);
            },
            Q::Term::Sub(term) {
                my name = term.identifier && term.identifier.name || "(anon)";
                return new Sub {
                    name,
                    parameterlist: term.block.parameterlist,
                    statementlist: term.block.statementlist,
                    "static-lexpad": term.block["static-lexpad"],
                    "outer-frame": current_frame(),
                };
            },

            # these were added to be able to run more tests
            # please move and implement as necessary
            Q::Block(block) {
            },
            Q::Infix(op) {
            },
            Q::Infix::Multiplication(op) {
            },
            Q::Infix::Modulo(op) {
            },
            Q::Infix::Divisibility(op) {
            },
            Q::Infix::Replicate(op) {
            },
            Q::Infix::ArrayReplicate(op) {
            },
            Q::Infix::Cons(op) {
            },
            Q::Infix::Ne(op) {
            },
            Q::Infix::Gt(op) {
            },
            Q::Infix::Lt(op) {
            },
            Q::Infix::Ge(op) {
            },
            Q::Infix::Le(op) {
            },
            Q::Infix::Or(op) {
            },
            Q::Infix::And(op) {
            },
            Q::Infix::TypeEq(op) {
            },
            Q::Postfix(op) {
            },
            Q::Postfix::Property(op) {
            },
            Q::Prefix(op) {
            },
            Q::Prefix::Minus(op) {
            },
            Q::Prefix::Not(op) {
            },
            Q::Prefix::Upto(op) {
            },
            Q::Term::Object(term) {
            },
            Q::Term::Quasi(term) {
            },
            Q::Expr::StatementListAdapter(adapter) {
            },
        };
        sub eval(q) { return eval_of_type[type(q).name](q); }

        my run_of_type = {
            Q::CompUnit(compunit) {
                enter(reify(compunit.block));
                run(compunit.block.statementlist);
                leave();
            },
            Q::Statement::Block(stmt) {
                enter(reify(stmt.block));
                run(stmt.block.statementlist);
                leave();
            },
            Q::Statement::Expr(stmt) {
                eval(stmt.expr);
            },
            Q::Statement::My(stmt) {
                my name = stmt.identifier.name;
                if stmt.expr {
                    put_var(name, eval(stmt.expr));
                }
            },
            Q::StatementList(stmtlist) {
                for stmtlist.statements -> statement {
                    run(statement);
                }
            },

            # these were added to be able to run more tests
            # please move and implement as necessary
            Q::Statement::BEGIN(stmt) {
            },
            Q::Statement::Constant(stmt) {
            },
            Q::Statement::For(stmt) {
            },
            Q::Statement::If(stmt) {
            },
            Q::Statement::Macro(stmt) {
            },
            Q::Statement::Return(stmt) {
            },
            Q::Statement::Sub(stmt) {
            },
            Q::Statement::While(stmt) {
            },
        };
        sub run(q) { run_of_type[type(q).name](q); }

        return { run, get_var, put_var };
    }
};

my output = RealOutput.new();
my runtime = Runtime.new({ output });
runtime.run(ast);
